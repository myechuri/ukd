// Code generated by protoc-gen-go.
// source: api.proto
// DO NOT EDIT!

/*
Package api is a generated protocol buffer package.

It is generated from these files:
	api.proto

It has these top-level messages:
	VersionRequest
	VersionReply
	StartRequest
	StartReply
	StopRequest
	StopReply
	UpdateImageRequest
	UpdateImageReply
*/
package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type VersionRequest struct {
}

func (m *VersionRequest) Reset()                    { *m = VersionRequest{} }
func (m *VersionRequest) String() string            { return proto.CompactTextString(m) }
func (*VersionRequest) ProtoMessage()               {}
func (*VersionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Ukd server version.
type VersionReply struct {
	Major int32 `protobuf:"varint,1,opt,name=major" json:"major,omitempty"`
	Minor int32 `protobuf:"varint,2,opt,name=minor" json:"minor,omitempty"`
}

func (m *VersionReply) Reset()                    { *m = VersionReply{} }
func (m *VersionReply) String() string            { return proto.CompactTextString(m) }
func (*VersionReply) ProtoMessage()               {}
func (*VersionReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// Request message containing image name and image location.
type StartRequest struct {
	Name     string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Visor    string `protobuf:"bytes,2,opt,name=visor" json:"visor,omitempty"`
	Location string `protobuf:"bytes,3,opt,name=location" json:"location,omitempty"`
}

func (m *StartRequest) Reset()                    { *m = StartRequest{} }
func (m *StartRequest) String() string            { return proto.CompactTextString(m) }
func (*StartRequest) ProtoMessage()               {}
func (*StartRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// Response message signalling result of start attempt.
type StartReply struct {
	Success bool   `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
	Ip      string `protobuf:"bytes,2,opt,name=ip" json:"ip,omitempty"`
	Info    string `protobuf:"bytes,3,opt,name=info" json:"info,omitempty"`
}

func (m *StartReply) Reset()                    { *m = StartReply{} }
func (m *StartReply) String() string            { return proto.CompactTextString(m) }
func (*StartReply) ProtoMessage()               {}
func (*StartReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// Request message containing the image name.
type StopRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *StopRequest) Reset()                    { *m = StopRequest{} }
func (m *StopRequest) String() string            { return proto.CompactTextString(m) }
func (*StopRequest) ProtoMessage()               {}
func (*StopRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// Response message signalling result of stop attempt.
type StopReply struct {
	Success bool   `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
	Info    string `protobuf:"bytes,2,opt,name=info" json:"info,omitempty"`
}

func (m *StopReply) Reset()                    { *m = StopReply{} }
func (m *StopReply) String() string            { return proto.CompactTextString(m) }
func (*StopReply) ProtoMessage()               {}
func (*StopReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type UpdateImageRequest struct {
	Base    string `protobuf:"bytes,1,opt,name=base" json:"base,omitempty"`
	Basesig []byte `protobuf:"bytes,2,opt,name=basesig,proto3" json:"basesig,omitempty"`
	Diff    []byte `protobuf:"bytes,3,opt,name=diff,proto3" json:"diff,omitempty"`
}

func (m *UpdateImageRequest) Reset()                    { *m = UpdateImageRequest{} }
func (m *UpdateImageRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateImageRequest) ProtoMessage()               {}
func (*UpdateImageRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type UpdateImageReply struct {
	Success bool   `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
	Info    string `protobuf:"bytes,2,opt,name=info" json:"info,omitempty"`
}

func (m *UpdateImageReply) Reset()                    { *m = UpdateImageReply{} }
func (m *UpdateImageReply) String() string            { return proto.CompactTextString(m) }
func (*UpdateImageReply) ProtoMessage()               {}
func (*UpdateImageReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func init() {
	proto.RegisterType((*VersionRequest)(nil), "VersionRequest")
	proto.RegisterType((*VersionReply)(nil), "VersionReply")
	proto.RegisterType((*StartRequest)(nil), "StartRequest")
	proto.RegisterType((*StartReply)(nil), "StartReply")
	proto.RegisterType((*StopRequest)(nil), "StopRequest")
	proto.RegisterType((*StopReply)(nil), "StopReply")
	proto.RegisterType((*UpdateImageRequest)(nil), "UpdateImageRequest")
	proto.RegisterType((*UpdateImageReply)(nil), "UpdateImageReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for Ukd service

type UkdClient interface {
	// Get Server Version.
	GetVersion(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*VersionReply, error)
	// Start a Unikernel.
	Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartReply, error)
	// Stop a Unikernel.
	Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopReply, error)
	// Update a Unikernel on-disk image.
	UpdateImage(ctx context.Context, in *UpdateImageRequest, opts ...grpc.CallOption) (*UpdateImageReply, error)
}

type ukdClient struct {
	cc *grpc.ClientConn
}

func NewUkdClient(cc *grpc.ClientConn) UkdClient {
	return &ukdClient{cc}
}

func (c *ukdClient) GetVersion(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*VersionReply, error) {
	out := new(VersionReply)
	err := grpc.Invoke(ctx, "/Ukd/GetVersion", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ukdClient) Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartReply, error) {
	out := new(StartReply)
	err := grpc.Invoke(ctx, "/Ukd/Start", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ukdClient) Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopReply, error) {
	out := new(StopReply)
	err := grpc.Invoke(ctx, "/Ukd/Stop", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ukdClient) UpdateImage(ctx context.Context, in *UpdateImageRequest, opts ...grpc.CallOption) (*UpdateImageReply, error) {
	out := new(UpdateImageReply)
	err := grpc.Invoke(ctx, "/Ukd/UpdateImage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Ukd service

type UkdServer interface {
	// Get Server Version.
	GetVersion(context.Context, *VersionRequest) (*VersionReply, error)
	// Start a Unikernel.
	Start(context.Context, *StartRequest) (*StartReply, error)
	// Stop a Unikernel.
	Stop(context.Context, *StopRequest) (*StopReply, error)
	// Update a Unikernel on-disk image.
	UpdateImage(context.Context, *UpdateImageRequest) (*UpdateImageReply, error)
}

func RegisterUkdServer(s *grpc.Server, srv UkdServer) {
	s.RegisterService(&_Ukd_serviceDesc, srv)
}

func _Ukd_GetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UkdServer).GetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Ukd/GetVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UkdServer).GetVersion(ctx, req.(*VersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ukd_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UkdServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Ukd/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UkdServer).Start(ctx, req.(*StartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ukd_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UkdServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Ukd/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UkdServer).Stop(ctx, req.(*StopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ukd_UpdateImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UkdServer).UpdateImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Ukd/UpdateImage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UkdServer).UpdateImage(ctx, req.(*UpdateImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Ukd_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Ukd",
	HandlerType: (*UkdServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVersion",
			Handler:    _Ukd_GetVersion_Handler,
		},
		{
			MethodName: "Start",
			Handler:    _Ukd_Start_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _Ukd_Stop_Handler,
		},
		{
			MethodName: "UpdateImage",
			Handler:    _Ukd_UpdateImage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: fileDescriptor0,
}

func init() { proto.RegisterFile("api.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 339 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x92, 0x4f, 0x4f, 0x32, 0x31,
	0x10, 0xc6, 0xf9, 0xfb, 0xbe, 0xec, 0xb0, 0x20, 0x8e, 0x1e, 0xc8, 0x9e, 0xb4, 0x89, 0x89, 0xa7,
	0x1e, 0xf4, 0x60, 0xf4, 0xe4, 0xcd, 0xe8, 0xb1, 0x08, 0xf7, 0x02, 0x85, 0x54, 0x61, 0x5b, 0xb7,
	0xc5, 0xc4, 0x8f, 0xe6, 0xb7, 0x73, 0x5b, 0xca, 0x5a, 0x34, 0x21, 0xf1, 0xc4, 0x3c, 0xc3, 0xcc,
	0x6f, 0xa6, 0xf3, 0x2c, 0x24, 0x5c, 0x4b, 0xaa, 0x0b, 0x65, 0x15, 0x19, 0x40, 0x7f, 0x22, 0x0a,
	0x23, 0x55, 0xce, 0xc4, 0xdb, 0x46, 0x18, 0x4b, 0xee, 0x20, 0xad, 0x32, 0x7a, 0xf5, 0x81, 0xa7,
	0xd0, 0x5e, 0xf3, 0x17, 0x55, 0x0c, 0xeb, 0x67, 0xf5, 0xcb, 0x36, 0xdb, 0x0a, 0x9f, 0x95, 0x79,
	0x99, 0x6d, 0x84, 0xac, 0x13, 0xe4, 0x19, 0xd2, 0x91, 0xe5, 0x85, 0x0d, 0x2c, 0x44, 0x68, 0xe5,
	0x7c, 0x2d, 0x7c, 0x6b, 0xc2, 0x7c, 0xec, 0x3a, 0xdf, 0xa5, 0x09, 0x9d, 0x09, 0xdb, 0x0a, 0xcc,
	0xa0, 0xb3, 0x52, 0x33, 0x6e, 0xcb, 0xb1, 0xc3, 0xa6, 0xff, 0xa3, 0xd2, 0xe4, 0x09, 0x20, 0x50,
	0xdd, 0x3e, 0x43, 0xf8, 0x6f, 0x36, 0xb3, 0x99, 0x30, 0xc6, 0x63, 0x3b, 0x6c, 0x27, 0xb1, 0x0f,
	0x0d, 0xa9, 0x03, 0xb6, 0x8c, 0xdc, 0x74, 0x99, 0x2f, 0x54, 0xe0, 0xf9, 0x98, 0x9c, 0x43, 0x77,
	0x64, 0x95, 0x3e, 0xb0, 0x20, 0xb9, 0x85, 0x64, 0x5b, 0x72, 0x78, 0xda, 0x8e, 0xde, 0x88, 0xe8,
	0x13, 0xc0, 0xb1, 0x9e, 0x73, 0x2b, 0x1e, 0xd7, 0x7c, 0x29, 0xa2, 0x21, 0x53, 0x6e, 0xaa, 0x21,
	0x2e, 0x76, 0x5c, 0xf7, 0x6b, 0xe4, 0xd2, 0x03, 0x52, 0xb6, 0x93, 0xae, 0x7a, 0x2e, 0x17, 0x0b,
	0xbf, 0x75, 0xca, 0x7c, 0x4c, 0xee, 0x61, 0xb0, 0xc7, 0xfd, 0xf3, 0x66, 0x57, 0x9f, 0x75, 0x68,
	0x8e, 0x5f, 0xe7, 0x48, 0x01, 0x1e, 0x84, 0x0d, 0x06, 0xe3, 0x11, 0xdd, 0x37, 0x3f, 0xeb, 0xd1,
	0xd8, 0x7b, 0x52, 0xc3, 0x0b, 0x68, 0xfb, 0xdb, 0x63, 0x8f, 0xc6, 0xce, 0x66, 0x5d, 0xfa, 0x6d,
	0x49, 0x59, 0x46, 0xa0, 0xe5, 0x6e, 0x86, 0x29, 0x8d, 0xae, 0x9b, 0x01, 0xad, 0x0e, 0x59, 0xd6,
	0xdc, 0x40, 0x37, 0x7a, 0x04, 0x9e, 0xd0, 0xdf, 0xa7, 0xca, 0x8e, 0xe9, 0xcf, 0x77, 0x92, 0xda,
	0xf4, 0x9f, 0xff, 0x54, 0xaf, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff, 0xf5, 0x48, 0x5c, 0x13, 0xb7,
	0x02, 0x00, 0x00,
}
